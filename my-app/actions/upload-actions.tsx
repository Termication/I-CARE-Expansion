'use server';

import { extractTextFromPdf } from "@/lib/langchain";
import type { ClientUploadedFileData } from "uploadthing/types";
import { generateFromOpenAI } from "@/lib/openai";
import { generateSummaryFromDeekseek } from "@/lib/deepseek";
import { auth } from "@clerk/nextjs/server";
import { getData } from "@/lib/db";
import { revalidatePath } from "next/cache";


// Generate a summary from the PDF
export async function generatePdfSummary(uploadResponse: ClientUploadedFileData<{
  userId: string;
  fileUrl: string;
  fileName: string;
}>[]) {
  if (!uploadResponse?.length) {
    return {
      success: false,
      message: "No upload response provided.",
      data: null,
    };
  }

  const { fileUrl } = uploadResponse[0].serverData;

  if (!fileUrl) {
    return {
      success: false,
      message: "No PDF URL provided.",
      data: null,
    };
  }

  try {
    const pdfText = await extractTextFromPdf(fileUrl);

    try {
      const summary = await generateFromOpenAI(pdfText);
      return {
        success: true,
        message: "Summary generated by OpenAI.",
        data: { summary },
      };
    } catch (error: any) {
      if (error.message?.includes("Rate limit") || error.message?.includes("quota")) {
        try {
          const fallback = await generateSummaryFromDeekseek(pdfText);
          return {
            success: true,
            message: "Summary generated by DeepSeek (fallback).",
            data: { summary: fallback },
          };
        } catch {
          return {
            success: false,
            message: "Both OpenAI and DeepSeek APIs are currently over quota.",
            data: null,
          };
        }
      }

      return {
        success: false,
        message: `OpenAI error: ${error.message}`,
        data: null,
      };
    }
  } catch (err: any) {
    console.error("PDF extraction error:", err);
    return {
      success: false,
      message: "Error extracting text from PDF.",
      data: null,
    };
  }
}


// Save summary to database and return id
async function savePdfSummary({
  userId,
  filename,
  fileUrl,
  summary,
}: {
  userId: string;
  filename: string;
  fileUrl: string;
  summary: string;
}) {
  try {
    const sql = await getData();

    const [row] = await sql`
      INSERT INTO pdf_summaries (
        user_id,
        file_name,
        original_file_url,
        summary_text
      )
      VALUES (
        ${userId},
        ${filename},
        ${fileUrl},
        ${summary}
      )
      RETURNING id;
    `;

    return row?.id;
  } catch (error: any) {
    console.error("Error storing PDF summary:", error);
    return null;
  }
}


// Public action: called from UploadForm
interface PdfSummaryData {
  filename: string;
  fileUrl: string;
  summary: string;
}

export async function storePdfSummary({
  filename,
  fileUrl,
  summary,
}: PdfSummaryData) {
  try {
    const session = await auth();
    if (!session?.userId) {
      return {
        success: false,
        message: "User not authenticated.",
      };
    }

    const summaryId = await savePdfSummary({
      userId: session.userId,
      filename,
      fileUrl,
      summary,
    });

    if (!summaryId) {
      return {
        success: false,
        message: "Failed to store PDF summary.",
      };
    }

    // Revalidate both the detail and list pages
    revalidatePath(`/summary/${summaryId}`);
    revalidatePath("/summaries");

    return {
      success: true,
      message: "PDF summary stored successfully.",
      data: { id: summaryId },
    };
  } catch (error: any) {
    console.error("storePdfSummary error:", error);
    return {
      success: false,
      message: "An error occurred while storing the summary.",
    };
  }
}
